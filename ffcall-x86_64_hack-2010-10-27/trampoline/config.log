This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by libffcall/trampoline configure 0x010B, which was
generated by GNU Autoconf 2.65.  Invocation command line was

  $ ./configure --disable-option-checking --prefix=/usr/local --build=x86_64-apple-darwin10.4.0 build_alias=x86_64-apple-darwin10.4.0 CC=/usr/bin/cc CFLAGS=-O3 -w -pipe --cache-file=/dev/null --srcdir=.

## --------- ##
## Platform. ##
## --------- ##

hostname = vinyl
uname -m = i386
uname -r = 10.4.0
uname -s = Darwin
uname -v = Darwin Kernel Version 10.4.0: Fri Apr 23 18:28:53 PDT 2010; root:xnu-1504.7.4~1/RELEASE_I386

/usr/bin/uname -p = i386
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = Mach kernel version:
	 Darwin Kernel Version 10.4.0: Fri Apr 23 18:28:53 PDT 2010; root:xnu-1504.7.4~1/RELEASE_I386
Kernel configured for up to 4 processors.
2 processors are physically available.
4 processors are logically available.
Processor type: i486 (Intel 80486)
Processors active: 0 1 2 3
Primary memory available: 8.00 gigabytes
Default processor set: 166 tasks, 853 threads, 4 processors
Load average: 4.47, Mach factor: 0.53
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /usr/local/bin
PATH: /usr/local/bin
PATH: /usr/bin
PATH: /bin
PATH: /usr/sbin
PATH: /sbin
PATH: /usr/local/bin
PATH: /usr/X11/bin
PATH: /opt/local/bin
PATH: /Users/enki/Code/ec2-api-tools-1.3-30349/bin
PATH: /usr/local/sbin
PATH: /opt/local/bin
PATH: /Users/enki/Code/ec2-api-tools-1.3-30349/bin
PATH: /usr/local/sbin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2131: checking for gcc
configure:2158: result: /usr/bin/cc
configure:2387: checking for C compiler version
configure:2396: /usr/bin/cc --version >&5
i686-apple-darwin10-gcc-4.2.1 (GCC) 4.2.1 (Apple Inc. build 5664)
Copyright (C) 2007 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:2407: $? = 0
configure:2396: /usr/bin/cc -v >&5
Using built-in specs.
Target: i686-apple-darwin10
Configured with: /var/tmp/gcc/gcc-5664~38/src/configure --disable-checking --enable-werror --prefix=/usr --mandir=/share/man --enable-languages=c,objc,c++,obj-c++ --program-transform-name=/^[cg][^.-]*$/s/$/-4.2/ --with-slibdir=/usr/lib --build=i686-apple-darwin10 --program-prefix=i686-apple-darwin10- --host=x86_64-apple-darwin10 --target=i686-apple-darwin10 --with-gxx-include-dir=/include/c++/4.2.1
Thread model: posix
gcc version 4.2.1 (Apple Inc. build 5664)
configure:2407: $? = 0
configure:2396: /usr/bin/cc -V >&5
gcc-4.2: argument to `-V' is missing
configure:2407: $? = 1
configure:2396: /usr/bin/cc -qversion >&5
i686-apple-darwin10-gcc-4.2.1: no input files
configure:2407: $? = 1
configure:2427: checking whether the C compiler works
configure:2449: /usr/bin/cc -O3 -w -pipe   conftest.c  >&5
configure:2453: $? = 0
configure:2502: result: yes
configure:2505: checking for C compiler default output file name
configure:2507: result: a.out
configure:2513: checking for suffix of executables
configure:2520: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:2524: $? = 0
configure:2546: result: 
configure:2568: checking whether we are cross compiling
configure:2576: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:2580: $? = 0
configure:2587: ./conftest
configure:2591: $? = 0
configure:2606: result: no
configure:2611: checking for suffix of object files
configure:2633: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:2637: $? = 0
configure:2658: result: o
configure:2662: checking whether we are using the GNU C compiler
configure:2681: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:2681: $? = 0
configure:2690: result: yes
configure:2699: checking whether /usr/bin/cc accepts -g
configure:2719: /usr/bin/cc -c -g  conftest.c >&5
configure:2719: $? = 0
configure:2760: result: yes
configure:2777: checking for /usr/bin/cc option to accept ISO C89
configure:2841: /usr/bin/cc  -c -O3 -w -pipe  conftest.c >&5
configure:2841: $? = 0
configure:2854: result: none needed
configure:2879: checking how to run the C preprocessor
configure:2910: /usr/bin/cc -E  conftest.c
configure:2910: $? = 0
configure:2924: /usr/bin/cc -E  conftest.c
conftest.c:9:28: error: ac_nonexistent.h: No such file or directory
configure:2924: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:2949: result: /usr/bin/cc -E
configure:2969: /usr/bin/cc -E  conftest.c
configure:2969: $? = 0
configure:2983: /usr/bin/cc -E  conftest.c
conftest.c:9:28: error: ac_nonexistent.h: No such file or directory
configure:2983: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:3013: checking for grep that handles long lines and -e
configure:3071: result: /usr/bin/grep
configure:3076: checking for egrep
configure:3138: result: /usr/bin/grep -E
configure:3144: checking whether /usr/bin/cc needs -traditional
conftest.c:9:20: error: termio.h: No such file or directory
configure:3178: result: no
configure:3186: checking whether using GNU C
configure:3209: result: yes
configure:3221: checking for underscore in external names
configure:3235: /usr/bin/cc -S conftest.c
configure:3238: $? = 0
configure:3248: result: yes
configure:3302: checking for ranlib
configure:3318: found /usr/bin/ranlib
configure:3329: result: ranlib
configure:3351: checking whether make sets $(MAKE)
configure:3373: result: yes
configure:3419: checking for a BSD-compatible install
configure:3487: result: /usr/bin/install -c
configure:3498: checking how to make hard links
configure:3514: result: ln
configure:3518: checking whether ln -s works
configure:3532: result: yes
configure:3544: checking build system type
configure:3558: result: x86_64-apple-darwin10.4.0
configure:3578: checking host system type
configure:3591: result: x86_64-apple-darwin10.4.0
configure:3613: checking host CPU and C ABI
configure:3755: result: x86_64
configure:3771: checking for ANSI C header files
configure:3791: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3791: $? = 0
configure:3864: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:3864: $? = 0
configure:3864: ./conftest
configure:3864: $? = 0
configure:3875: result: yes
configure:3888: checking for sys/types.h
configure:3888: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3888: $? = 0
configure:3888: result: yes
configure:3888: checking for sys/stat.h
configure:3888: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3888: $? = 0
configure:3888: result: yes
configure:3888: checking for stdlib.h
configure:3888: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3888: $? = 0
configure:3888: result: yes
configure:3888: checking for string.h
configure:3888: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3888: $? = 0
configure:3888: result: yes
configure:3888: checking for memory.h
configure:3888: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3888: $? = 0
configure:3888: result: yes
configure:3888: checking for strings.h
configure:3888: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3888: $? = 0
configure:3888: result: yes
configure:3888: checking for inttypes.h
configure:3888: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3888: $? = 0
configure:3888: result: yes
configure:3888: checking for stdint.h
configure:3888: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3888: $? = 0
configure:3888: result: yes
configure:3888: checking for unistd.h
configure:3888: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3888: $? = 0
configure:3888: result: yes
configure:3903: checking for unistd_h
configure:3903: result: yes
configure:3914: checking for getpagesize
configure:3935: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:3935: $? = 0
configure:3943: result: yes
configure:3952: checking for getpagesize declaration
configure:3981: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:3981: $? = 0
configure:3994: result: install-shextern int getpagesize (void);
configure:4018: checking for vm_allocate
configure:4034: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
Undefined symbols:
  "_task_self", referenced from:
      _main in ccNcUL9h.o
ld: symbol(s) not found
collect2: ld returned 1 exit status
configure:4034: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| /* end confdefs.h.  */
| 
| int
| main ()
| {
| vm_allocate(); task_self();
|   ;
|   return 0;
| }
configure:4042: result: no
configure:4051: checking sys/mman.h usability
configure:4051: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:4051: $? = 0
configure:4051: result: yes
configure:4051: checking sys/mman.h presence
configure:4051: /usr/bin/cc -E  conftest.c
configure:4051: $? = 0
configure:4051: result: yes
configure:4051: checking for sys/mman.h
configure:4051: result: yes
configure:4059: checking for mmap
configure:4059: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:4059: $? = 0
configure:4059: result: yes
configure:4069: checking for working mmap
configure:4227: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:4227: $? = 0
configure:4227: ./conftest
configure:4227: $? = 1
configure: program exited with status 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| #define HAVE_MMAP /**/
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #if defined __MACH__ && defined __APPLE__
| /* Avoid a crash on MacOS X.  */
| #include <mach/mach.h>
| #include <mach/mach_error.h>
| #include <mach/thread_status.h>
| #include <mach/exception.h>
| #include <mach/task.h>
| #include <pthread.h>
| /* The exception port on which our thread listens.  */
| static mach_port_t our_exception_port;
| /* The main function of the thread listening for exceptions of type
|    EXC_BAD_ACCESS.  */
| static void *
| mach_exception_thread (void *arg)
| {
|   /* Buffer for a message to be received.  */
|   struct {
|     mach_msg_header_t head;
|     mach_msg_body_t msgh_body;
|     char data[1024];
|   } msg;
|   mach_msg_return_t retval;
|   /* Wait for a message on the exception port.  */
|   retval = mach_msg (&msg.head, MACH_RCV_MSG | MACH_RCV_LARGE, 0, sizeof (msg),
|                      our_exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
|   if (retval != MACH_MSG_SUCCESS)
|     abort ();
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
|   mach_port_t self = mach_task_self ();
|   /* Allocate a port on which the thread shall listen for exceptions.  */
|   if (mach_port_allocate (self, MACH_PORT_RIGHT_RECEIVE, &our_exception_port)
|       == KERN_SUCCESS) {
|     /* See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_port_insert_right.html.  */
|     if (mach_port_insert_right (self, our_exception_port, our_exception_port,
|                                 MACH_MSG_TYPE_MAKE_SEND)
|         == KERN_SUCCESS) {
|       /* The exceptions we want to catch.  Only EXC_BAD_ACCESS is interesting
|          for us.  */
|       exception_mask_t mask = EXC_MASK_BAD_ACCESS;
|       /* Create the thread listening on the exception port.  */
|       pthread_attr_t attr;
|       pthread_t thread;
|       if (pthread_attr_init (&attr) == 0
|           && pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) == 0
|           && pthread_create (&thread, &attr, mach_exception_thread, NULL) == 0) {
|         pthread_attr_destroy (&attr);
|         /* Replace the exception port info for these exceptions with our own.
|            Note that we replace the exception port for the entire task, not only
|            for a particular thread.  This has the effect that when our exception
|            port gets the message, the thread specific exception port has already
|            been asked, and we don't need to bother about it.
|            See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_set_exception_ports.html.  */
|         task_set_exception_ports (self, mask, our_exception_port,
|                                   EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
|       }
|     }
|   }
| }
| #else
| /* Avoid a crash on POSIX systems.  */
| #include <signal.h>
| /* A POSIX signal handler.  */
| static void
| exception_handler (int sig)
| {
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
| #ifdef SIGSEGV
|   signal (SIGSEGV, exception_handler);
| #endif
| #ifdef SIGBUS
|   signal (SIGBUS, exception_handler);
| #endif
| }
| #endif
| 
| #include <stdlib.h>
| #ifdef HAVE_UNISTD_H
| #include <unistd.h>
| #endif
| #include <fcntl.h>
| #include <sys/types.h>
| #include <sys/mman.h>
| int main () {
| 
|   int flags = MAP_ANON | MAP_PRIVATE;
|   int fd = -1;
|   nocrash_init();
| #define bits_to_avoid 0
| #define my_shift 24
| #define my_low   1
| #ifdef FOR_SUN4_29
| #define my_high  31
| #define my_size  32768 /* hope that 32768 is a multiple of the page size */
| /* i*32 KB for i=1..31 gives a total of 15.5 MB, which is close to what we need */
| #else
| #define my_high  64
| #define my_size  8192 /* hope that 8192 is a multiple of the page size */
| /* i*8 KB for i=1..64 gives a total of 16.25 MB, which is close to what we need */
| #endif
|  {long i;
| #define i_ok(i)  ((i) & (bits_to_avoid >> my_shift) == 0)
|   for (i=my_low; i<=my_high; i++)
|     if (i_ok(i))
|       { caddr_t addr = (caddr_t)(i << my_shift);
| /* Check for 8 MB, not 16 MB. This is more likely to work on Solaris 2. */
| #if bits_to_avoid
|         long size = i*my_size;
| #else
|         long size = ((i+1)/2)*my_size;
| #endif
|         if (mmap(addr,size,PROT_READ|PROT_WRITE,flags|MAP_FIXED,fd,0) == (void*)-1) exit(1);
|     }
| #define x(i)  *(unsigned char *) ((i<<my_shift) + (i*i))
| #define y(i)  (unsigned char)((3*i-4)*(7*i+3))
|   for (i=my_low; i<=my_high; i++) if (i_ok(i)) { x(i) = y(i); }
|   for (i=my_high; i>=my_low; i--) if (i_ok(i)) { if (x(i) != y(i)) exit(1); }
|   exit(0);
| }}
| 
| 
configure:4332: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
conftest.c: In function 'main':
conftest.c:121: error: 'MAP_ANONYMOUS' undeclared (first use in this function)
conftest.c:121: error: (Each undeclared identifier is reported only once
conftest.c:121: error: for each function it appears in.)
configure:4332: $? = 1
configure: program exited with status 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| #define HAVE_MMAP /**/
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #if defined __MACH__ && defined __APPLE__
| /* Avoid a crash on MacOS X.  */
| #include <mach/mach.h>
| #include <mach/mach_error.h>
| #include <mach/thread_status.h>
| #include <mach/exception.h>
| #include <mach/task.h>
| #include <pthread.h>
| /* The exception port on which our thread listens.  */
| static mach_port_t our_exception_port;
| /* The main function of the thread listening for exceptions of type
|    EXC_BAD_ACCESS.  */
| static void *
| mach_exception_thread (void *arg)
| {
|   /* Buffer for a message to be received.  */
|   struct {
|     mach_msg_header_t head;
|     mach_msg_body_t msgh_body;
|     char data[1024];
|   } msg;
|   mach_msg_return_t retval;
|   /* Wait for a message on the exception port.  */
|   retval = mach_msg (&msg.head, MACH_RCV_MSG | MACH_RCV_LARGE, 0, sizeof (msg),
|                      our_exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
|   if (retval != MACH_MSG_SUCCESS)
|     abort ();
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
|   mach_port_t self = mach_task_self ();
|   /* Allocate a port on which the thread shall listen for exceptions.  */
|   if (mach_port_allocate (self, MACH_PORT_RIGHT_RECEIVE, &our_exception_port)
|       == KERN_SUCCESS) {
|     /* See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_port_insert_right.html.  */
|     if (mach_port_insert_right (self, our_exception_port, our_exception_port,
|                                 MACH_MSG_TYPE_MAKE_SEND)
|         == KERN_SUCCESS) {
|       /* The exceptions we want to catch.  Only EXC_BAD_ACCESS is interesting
|          for us.  */
|       exception_mask_t mask = EXC_MASK_BAD_ACCESS;
|       /* Create the thread listening on the exception port.  */
|       pthread_attr_t attr;
|       pthread_t thread;
|       if (pthread_attr_init (&attr) == 0
|           && pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) == 0
|           && pthread_create (&thread, &attr, mach_exception_thread, NULL) == 0) {
|         pthread_attr_destroy (&attr);
|         /* Replace the exception port info for these exceptions with our own.
|            Note that we replace the exception port for the entire task, not only
|            for a particular thread.  This has the effect that when our exception
|            port gets the message, the thread specific exception port has already
|            been asked, and we don't need to bother about it.
|            See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_set_exception_ports.html.  */
|         task_set_exception_ports (self, mask, our_exception_port,
|                                   EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
|       }
|     }
|   }
| }
| #else
| /* Avoid a crash on POSIX systems.  */
| #include <signal.h>
| /* A POSIX signal handler.  */
| static void
| exception_handler (int sig)
| {
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
| #ifdef SIGSEGV
|   signal (SIGSEGV, exception_handler);
| #endif
| #ifdef SIGBUS
|   signal (SIGBUS, exception_handler);
| #endif
| }
| #endif
| 
| #include <stdlib.h>
| #ifdef HAVE_UNISTD_H
| #include <unistd.h>
| #endif
| #include <fcntl.h>
| #include <sys/types.h>
| #include <sys/mman.h>
| int main () {
| 
|   int flags = MAP_ANONYMOUS | MAP_PRIVATE;
|   int fd = -1;
|   nocrash_init();
| #define bits_to_avoid 0
| #define my_shift 24
| #define my_low   1
| #ifdef FOR_SUN4_29
| #define my_high  31
| #define my_size  32768 /* hope that 32768 is a multiple of the page size */
| /* i*32 KB for i=1..31 gives a total of 15.5 MB, which is close to what we need */
| #else
| #define my_high  64
| #define my_size  8192 /* hope that 8192 is a multiple of the page size */
| /* i*8 KB for i=1..64 gives a total of 16.25 MB, which is close to what we need */
| #endif
|  {long i;
| #define i_ok(i)  ((i) & (bits_to_avoid >> my_shift) == 0)
|   for (i=my_low; i<=my_high; i++)
|     if (i_ok(i))
|       { caddr_t addr = (caddr_t)(i << my_shift);
| /* Check for 8 MB, not 16 MB. This is more likely to work on Solaris 2. */
| #if bits_to_avoid
|         long size = i*my_size;
| #else
|         long size = ((i+1)/2)*my_size;
| #endif
|         if (mmap(addr,size,PROT_READ|PROT_WRITE,flags|MAP_FIXED,fd,0) == (void*)-1) exit(1);
|     }
| #define x(i)  *(unsigned char *) ((i<<my_shift) + (i*i))
| #define y(i)  (unsigned char)((3*i-4)*(7*i+3))
|   for (i=my_low; i<=my_high; i++) if (i_ok(i)) { x(i) = y(i); }
|   for (i=my_high; i>=my_low; i--) if (i_ok(i)) { if (x(i) != y(i)) exit(1); }
|   exit(0);
| }}
| 
| 
configure:4441: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:4441: $? = 0
configure:4441: ./conftest
configure:4441: $? = 1
configure: program exited with status 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| #define HAVE_MMAP /**/
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #if defined __MACH__ && defined __APPLE__
| /* Avoid a crash on MacOS X.  */
| #include <mach/mach.h>
| #include <mach/mach_error.h>
| #include <mach/thread_status.h>
| #include <mach/exception.h>
| #include <mach/task.h>
| #include <pthread.h>
| /* The exception port on which our thread listens.  */
| static mach_port_t our_exception_port;
| /* The main function of the thread listening for exceptions of type
|    EXC_BAD_ACCESS.  */
| static void *
| mach_exception_thread (void *arg)
| {
|   /* Buffer for a message to be received.  */
|   struct {
|     mach_msg_header_t head;
|     mach_msg_body_t msgh_body;
|     char data[1024];
|   } msg;
|   mach_msg_return_t retval;
|   /* Wait for a message on the exception port.  */
|   retval = mach_msg (&msg.head, MACH_RCV_MSG | MACH_RCV_LARGE, 0, sizeof (msg),
|                      our_exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
|   if (retval != MACH_MSG_SUCCESS)
|     abort ();
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
|   mach_port_t self = mach_task_self ();
|   /* Allocate a port on which the thread shall listen for exceptions.  */
|   if (mach_port_allocate (self, MACH_PORT_RIGHT_RECEIVE, &our_exception_port)
|       == KERN_SUCCESS) {
|     /* See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_port_insert_right.html.  */
|     if (mach_port_insert_right (self, our_exception_port, our_exception_port,
|                                 MACH_MSG_TYPE_MAKE_SEND)
|         == KERN_SUCCESS) {
|       /* The exceptions we want to catch.  Only EXC_BAD_ACCESS is interesting
|          for us.  */
|       exception_mask_t mask = EXC_MASK_BAD_ACCESS;
|       /* Create the thread listening on the exception port.  */
|       pthread_attr_t attr;
|       pthread_t thread;
|       if (pthread_attr_init (&attr) == 0
|           && pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) == 0
|           && pthread_create (&thread, &attr, mach_exception_thread, NULL) == 0) {
|         pthread_attr_destroy (&attr);
|         /* Replace the exception port info for these exceptions with our own.
|            Note that we replace the exception port for the entire task, not only
|            for a particular thread.  This has the effect that when our exception
|            port gets the message, the thread specific exception port has already
|            been asked, and we don't need to bother about it.
|            See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_set_exception_ports.html.  */
|         task_set_exception_ports (self, mask, our_exception_port,
|                                   EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
|       }
|     }
|   }
| }
| #else
| /* Avoid a crash on POSIX systems.  */
| #include <signal.h>
| /* A POSIX signal handler.  */
| static void
| exception_handler (int sig)
| {
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
| #ifdef SIGSEGV
|   signal (SIGSEGV, exception_handler);
| #endif
| #ifdef SIGBUS
|   signal (SIGBUS, exception_handler);
| #endif
| }
| #endif
| 
| #include <stdlib.h>
| #ifdef HAVE_UNISTD_H
| #include <unistd.h>
| #endif
| #include <fcntl.h>
| #include <sys/types.h>
| #include <sys/mman.h>
| int main () {
| 
| #ifndef MAP_FILE
| #define MAP_FILE 0
| #endif
|   int flags = MAP_FILE | MAP_PRIVATE;
|   int fd = open("/dev/zero",O_RDONLY,0666);
|   if (fd<0) exit(1);
|   nocrash_init();
| #define bits_to_avoid 0
| #define my_shift 24
| #define my_low   1
| #ifdef FOR_SUN4_29
| #define my_high  31
| #define my_size  32768 /* hope that 32768 is a multiple of the page size */
| /* i*32 KB for i=1..31 gives a total of 15.5 MB, which is close to what we need */
| #else
| #define my_high  64
| #define my_size  8192 /* hope that 8192 is a multiple of the page size */
| /* i*8 KB for i=1..64 gives a total of 16.25 MB, which is close to what we need */
| #endif
|  {long i;
| #define i_ok(i)  ((i) & (bits_to_avoid >> my_shift) == 0)
|   for (i=my_low; i<=my_high; i++)
|     if (i_ok(i))
|       { caddr_t addr = (caddr_t)(i << my_shift);
| /* Check for 8 MB, not 16 MB. This is more likely to work on Solaris 2. */
| #if bits_to_avoid
|         long size = i*my_size;
| #else
|         long size = ((i+1)/2)*my_size;
| #endif
|         if (mmap(addr,size,PROT_READ|PROT_WRITE,flags|MAP_FIXED,fd,0) == (void*)-1) exit(1);
|     }
| #define x(i)  *(unsigned char *) ((i<<my_shift) + (i*i))
| #define y(i)  (unsigned char)((3*i-4)*(7*i+3))
|   for (i=my_low; i<=my_high; i++) if (i_ok(i)) { x(i) = y(i); }
|   for (i=my_high; i>=my_low; i--) if (i_ok(i)) { if (x(i) != y(i)) exit(1); }
|   exit(0);
| }}
| 
| 
configure:4554: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:4554: $? = 0
configure:4554: ./conftest
configure:4554: $? = 1
configure: program exited with status 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| #define HAVE_MMAP /**/
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #if defined __MACH__ && defined __APPLE__
| /* Avoid a crash on MacOS X.  */
| #include <mach/mach.h>
| #include <mach/mach_error.h>
| #include <mach/thread_status.h>
| #include <mach/exception.h>
| #include <mach/task.h>
| #include <pthread.h>
| /* The exception port on which our thread listens.  */
| static mach_port_t our_exception_port;
| /* The main function of the thread listening for exceptions of type
|    EXC_BAD_ACCESS.  */
| static void *
| mach_exception_thread (void *arg)
| {
|   /* Buffer for a message to be received.  */
|   struct {
|     mach_msg_header_t head;
|     mach_msg_body_t msgh_body;
|     char data[1024];
|   } msg;
|   mach_msg_return_t retval;
|   /* Wait for a message on the exception port.  */
|   retval = mach_msg (&msg.head, MACH_RCV_MSG | MACH_RCV_LARGE, 0, sizeof (msg),
|                      our_exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
|   if (retval != MACH_MSG_SUCCESS)
|     abort ();
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
|   mach_port_t self = mach_task_self ();
|   /* Allocate a port on which the thread shall listen for exceptions.  */
|   if (mach_port_allocate (self, MACH_PORT_RIGHT_RECEIVE, &our_exception_port)
|       == KERN_SUCCESS) {
|     /* See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_port_insert_right.html.  */
|     if (mach_port_insert_right (self, our_exception_port, our_exception_port,
|                                 MACH_MSG_TYPE_MAKE_SEND)
|         == KERN_SUCCESS) {
|       /* The exceptions we want to catch.  Only EXC_BAD_ACCESS is interesting
|          for us.  */
|       exception_mask_t mask = EXC_MASK_BAD_ACCESS;
|       /* Create the thread listening on the exception port.  */
|       pthread_attr_t attr;
|       pthread_t thread;
|       if (pthread_attr_init (&attr) == 0
|           && pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) == 0
|           && pthread_create (&thread, &attr, mach_exception_thread, NULL) == 0) {
|         pthread_attr_destroy (&attr);
|         /* Replace the exception port info for these exceptions with our own.
|            Note that we replace the exception port for the entire task, not only
|            for a particular thread.  This has the effect that when our exception
|            port gets the message, the thread specific exception port has already
|            been asked, and we don't need to bother about it.
|            See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_set_exception_ports.html.  */
|         task_set_exception_ports (self, mask, our_exception_port,
|                                   EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
|       }
|     }
|   }
| }
| #else
| /* Avoid a crash on POSIX systems.  */
| #include <signal.h>
| /* A POSIX signal handler.  */
| static void
| exception_handler (int sig)
| {
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
| #ifdef SIGSEGV
|   signal (SIGSEGV, exception_handler);
| #endif
| #ifdef SIGBUS
|   signal (SIGBUS, exception_handler);
| #endif
| }
| #endif
| #define FOR_SUN4_29
| 
| #include <stdlib.h>
| #ifdef HAVE_UNISTD_H
| #include <unistd.h>
| #endif
| #include <fcntl.h>
| #include <sys/types.h>
| #include <sys/mman.h>
| int main () {
| 
| #ifndef MAP_FILE
| #define MAP_FILE 0
| #endif
|   int flags = MAP_FILE | MAP_PRIVATE;
|   int fd = open("/dev/zero",O_RDONLY,0666);
|   if (fd<0) exit(1);
|   nocrash_init();
| #define bits_to_avoid 0
| #define my_shift 24
| #define my_low   1
| #ifdef FOR_SUN4_29
| #define my_high  31
| #define my_size  32768 /* hope that 32768 is a multiple of the page size */
| /* i*32 KB for i=1..31 gives a total of 15.5 MB, which is close to what we need */
| #else
| #define my_high  64
| #define my_size  8192 /* hope that 8192 is a multiple of the page size */
| /* i*8 KB for i=1..64 gives a total of 16.25 MB, which is close to what we need */
| #endif
|  {long i;
| #define i_ok(i)  ((i) & (bits_to_avoid >> my_shift) == 0)
|   for (i=my_low; i<=my_high; i++)
|     if (i_ok(i))
|       { caddr_t addr = (caddr_t)(i << my_shift);
| /* Check for 8 MB, not 16 MB. This is more likely to work on Solaris 2. */
| #if bits_to_avoid
|         long size = i*my_size;
| #else
|         long size = ((i+1)/2)*my_size;
| #endif
|         if (mmap(addr,size,PROT_READ|PROT_WRITE,flags|MAP_FIXED,fd,0) == (void*)-1) exit(1);
|     }
| #define x(i)  *(unsigned char *) ((i<<my_shift) + (i*i))
| #define y(i)  (unsigned char)((3*i-4)*(7*i+3))
|   for (i=my_low; i<=my_high; i++) if (i_ok(i)) { x(i) = y(i); }
|   for (i=my_high; i>=my_low; i--) if (i_ok(i)) { if (x(i) != y(i)) exit(1); }
|   exit(0);
| }}
| 
| 
configure:4570: result: no
configure:4597: checking for mprotect
configure:4597: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:4597: $? = 0
configure:4597: result: yes
configure:4606: checking for working mprotect
configure:4647: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:4647: $? = 0
configure:4647: ./conftest
configure:4647: $? = 0
configure:4757: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:4757: $? = 0
configure:4757: ./conftest
configure:4757: $? = 1
configure: program exited with status 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| #define HAVE_MMAP /**/
| #define HAVE_MPROTECT 1
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #if defined __MACH__ && defined __APPLE__
| /* Avoid a crash on MacOS X.  */
| #include <mach/mach.h>
| #include <mach/mach_error.h>
| #include <mach/thread_status.h>
| #include <mach/exception.h>
| #include <mach/task.h>
| #include <pthread.h>
| /* The exception port on which our thread listens.  */
| static mach_port_t our_exception_port;
| /* The main function of the thread listening for exceptions of type
|    EXC_BAD_ACCESS.  */
| static void *
| mach_exception_thread (void *arg)
| {
|   /* Buffer for a message to be received.  */
|   struct {
|     mach_msg_header_t head;
|     mach_msg_body_t msgh_body;
|     char data[1024];
|   } msg;
|   mach_msg_return_t retval;
|   /* Wait for a message on the exception port.  */
|   retval = mach_msg (&msg.head, MACH_RCV_MSG | MACH_RCV_LARGE, 0, sizeof (msg),
|                      our_exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
|   if (retval != MACH_MSG_SUCCESS)
|     abort ();
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
|   mach_port_t self = mach_task_self ();
|   /* Allocate a port on which the thread shall listen for exceptions.  */
|   if (mach_port_allocate (self, MACH_PORT_RIGHT_RECEIVE, &our_exception_port)
|       == KERN_SUCCESS) {
|     /* See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_port_insert_right.html.  */
|     if (mach_port_insert_right (self, our_exception_port, our_exception_port,
|                                 MACH_MSG_TYPE_MAKE_SEND)
|         == KERN_SUCCESS) {
|       /* The exceptions we want to catch.  Only EXC_BAD_ACCESS is interesting
|          for us.  */
|       exception_mask_t mask = EXC_MASK_BAD_ACCESS;
|       /* Create the thread listening on the exception port.  */
|       pthread_attr_t attr;
|       pthread_t thread;
|       if (pthread_attr_init (&attr) == 0
|           && pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) == 0
|           && pthread_create (&thread, &attr, mach_exception_thread, NULL) == 0) {
|         pthread_attr_destroy (&attr);
|         /* Replace the exception port info for these exceptions with our own.
|            Note that we replace the exception port for the entire task, not only
|            for a particular thread.  This has the effect that when our exception
|            port gets the message, the thread specific exception port has already
|            been asked, and we don't need to bother about it.
|            See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_set_exception_ports.html.  */
|         task_set_exception_ports (self, mask, our_exception_port,
|                                   EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
|       }
|     }
|   }
| }
| #else
| /* Avoid a crash on POSIX systems.  */
| #include <signal.h>
| /* A POSIX signal handler.  */
| static void
| exception_handler (int sig)
| {
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
| #ifdef SIGSEGV
|   signal (SIGSEGV, exception_handler);
| #endif
| #ifdef SIGBUS
|   signal (SIGBUS, exception_handler);
| #endif
| }
| #endif
| 
| #include <sys/types.h>
| /* declare malloc() */
| #include <stdlib.h>
| #ifdef HAVE_UNISTD_H
| #include <unistd.h>
| #endif
| /* declare getpagesize() and mprotect() */
| #include <sys/mman.h>
| #ifndef HAVE_GETPAGESIZE
| #include <sys/param.h>
| #define getpagesize() PAGESIZE
| #else
| extern
| #ifdef __cplusplus
| "C"
| #endif
| 
| RETGETPAGESIZETYPE getpagesize (void);
| #endif
| char foo;
| int main () {
|   unsigned long pagesize = getpagesize();
| #define page_align(address)  (char*)((unsigned long)(address) & -pagesize)
| 
|   char* area = (char*) malloc(6*pagesize);
|   char* fault_address = area + pagesize*7/2;
| 
|   nocrash_init();
|   if (mprotect(page_align(fault_address),pagesize,PROT_NONE) < 0) exit(0);
|   foo = *fault_address; /* this should cause an exception or signal */
|   exit(0); }
configure:4862: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:4862: $? = 0
configure:4862: ./conftest
configure:4862: $? = 1
configure: program exited with status 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| #define HAVE_MMAP /**/
| #define HAVE_MPROTECT 1
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #if defined __MACH__ && defined __APPLE__
| /* Avoid a crash on MacOS X.  */
| #include <mach/mach.h>
| #include <mach/mach_error.h>
| #include <mach/thread_status.h>
| #include <mach/exception.h>
| #include <mach/task.h>
| #include <pthread.h>
| /* The exception port on which our thread listens.  */
| static mach_port_t our_exception_port;
| /* The main function of the thread listening for exceptions of type
|    EXC_BAD_ACCESS.  */
| static void *
| mach_exception_thread (void *arg)
| {
|   /* Buffer for a message to be received.  */
|   struct {
|     mach_msg_header_t head;
|     mach_msg_body_t msgh_body;
|     char data[1024];
|   } msg;
|   mach_msg_return_t retval;
|   /* Wait for a message on the exception port.  */
|   retval = mach_msg (&msg.head, MACH_RCV_MSG | MACH_RCV_LARGE, 0, sizeof (msg),
|                      our_exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
|   if (retval != MACH_MSG_SUCCESS)
|     abort ();
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
|   mach_port_t self = mach_task_self ();
|   /* Allocate a port on which the thread shall listen for exceptions.  */
|   if (mach_port_allocate (self, MACH_PORT_RIGHT_RECEIVE, &our_exception_port)
|       == KERN_SUCCESS) {
|     /* See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_port_insert_right.html.  */
|     if (mach_port_insert_right (self, our_exception_port, our_exception_port,
|                                 MACH_MSG_TYPE_MAKE_SEND)
|         == KERN_SUCCESS) {
|       /* The exceptions we want to catch.  Only EXC_BAD_ACCESS is interesting
|          for us.  */
|       exception_mask_t mask = EXC_MASK_BAD_ACCESS;
|       /* Create the thread listening on the exception port.  */
|       pthread_attr_t attr;
|       pthread_t thread;
|       if (pthread_attr_init (&attr) == 0
|           && pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) == 0
|           && pthread_create (&thread, &attr, mach_exception_thread, NULL) == 0) {
|         pthread_attr_destroy (&attr);
|         /* Replace the exception port info for these exceptions with our own.
|            Note that we replace the exception port for the entire task, not only
|            for a particular thread.  This has the effect that when our exception
|            port gets the message, the thread specific exception port has already
|            been asked, and we don't need to bother about it.
|            See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_set_exception_ports.html.  */
|         task_set_exception_ports (self, mask, our_exception_port,
|                                   EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
|       }
|     }
|   }
| }
| #else
| /* Avoid a crash on POSIX systems.  */
| #include <signal.h>
| /* A POSIX signal handler.  */
| static void
| exception_handler (int sig)
| {
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
| #ifdef SIGSEGV
|   signal (SIGSEGV, exception_handler);
| #endif
| #ifdef SIGBUS
|   signal (SIGBUS, exception_handler);
| #endif
| }
| #endif
| 
| #include <sys/types.h>
| /* declare malloc() */
| #include <stdlib.h>
| #ifdef HAVE_UNISTD_H
| #include <unistd.h>
| #endif
| /* declare getpagesize() and mprotect() */
| #include <sys/mman.h>
| #ifndef HAVE_GETPAGESIZE
| #include <sys/param.h>
| #define getpagesize() PAGESIZE
| #else
| extern
| #ifdef __cplusplus
| "C"
| #endif
| 
| RETGETPAGESIZETYPE getpagesize (void);
| #endif
| char foo;
| int main () {
|   unsigned long pagesize = getpagesize();
| #define page_align(address)  (char*)((unsigned long)(address) & -pagesize)
| 
|   char* area = (char*) malloc(6*pagesize);
|   char* fault_address = area + pagesize*7/2;
| 
|   nocrash_init();
|   if (mprotect(page_align(fault_address),pagesize,PROT_NONE) < 0) exit(0);
|   *fault_address = 'z'; /* this should cause an exception or signal */
|   exit(0); }
configure:4967: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:4967: $? = 0
configure:4967: ./conftest
configure:4967: $? = 1
configure: program exited with status 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| #define HAVE_MMAP /**/
| #define HAVE_MPROTECT 1
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #if defined __MACH__ && defined __APPLE__
| /* Avoid a crash on MacOS X.  */
| #include <mach/mach.h>
| #include <mach/mach_error.h>
| #include <mach/thread_status.h>
| #include <mach/exception.h>
| #include <mach/task.h>
| #include <pthread.h>
| /* The exception port on which our thread listens.  */
| static mach_port_t our_exception_port;
| /* The main function of the thread listening for exceptions of type
|    EXC_BAD_ACCESS.  */
| static void *
| mach_exception_thread (void *arg)
| {
|   /* Buffer for a message to be received.  */
|   struct {
|     mach_msg_header_t head;
|     mach_msg_body_t msgh_body;
|     char data[1024];
|   } msg;
|   mach_msg_return_t retval;
|   /* Wait for a message on the exception port.  */
|   retval = mach_msg (&msg.head, MACH_RCV_MSG | MACH_RCV_LARGE, 0, sizeof (msg),
|                      our_exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
|   if (retval != MACH_MSG_SUCCESS)
|     abort ();
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
|   mach_port_t self = mach_task_self ();
|   /* Allocate a port on which the thread shall listen for exceptions.  */
|   if (mach_port_allocate (self, MACH_PORT_RIGHT_RECEIVE, &our_exception_port)
|       == KERN_SUCCESS) {
|     /* See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_port_insert_right.html.  */
|     if (mach_port_insert_right (self, our_exception_port, our_exception_port,
|                                 MACH_MSG_TYPE_MAKE_SEND)
|         == KERN_SUCCESS) {
|       /* The exceptions we want to catch.  Only EXC_BAD_ACCESS is interesting
|          for us.  */
|       exception_mask_t mask = EXC_MASK_BAD_ACCESS;
|       /* Create the thread listening on the exception port.  */
|       pthread_attr_t attr;
|       pthread_t thread;
|       if (pthread_attr_init (&attr) == 0
|           && pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) == 0
|           && pthread_create (&thread, &attr, mach_exception_thread, NULL) == 0) {
|         pthread_attr_destroy (&attr);
|         /* Replace the exception port info for these exceptions with our own.
|            Note that we replace the exception port for the entire task, not only
|            for a particular thread.  This has the effect that when our exception
|            port gets the message, the thread specific exception port has already
|            been asked, and we don't need to bother about it.
|            See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_set_exception_ports.html.  */
|         task_set_exception_ports (self, mask, our_exception_port,
|                                   EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
|       }
|     }
|   }
| }
| #else
| /* Avoid a crash on POSIX systems.  */
| #include <signal.h>
| /* A POSIX signal handler.  */
| static void
| exception_handler (int sig)
| {
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
| #ifdef SIGSEGV
|   signal (SIGSEGV, exception_handler);
| #endif
| #ifdef SIGBUS
|   signal (SIGBUS, exception_handler);
| #endif
| }
| #endif
| 
| #include <sys/types.h>
| /* declare malloc() */
| #include <stdlib.h>
| #ifdef HAVE_UNISTD_H
| #include <unistd.h>
| #endif
| /* declare getpagesize() and mprotect() */
| #include <sys/mman.h>
| #ifndef HAVE_GETPAGESIZE
| #include <sys/param.h>
| #define getpagesize() PAGESIZE
| #else
| extern
| #ifdef __cplusplus
| "C"
| #endif
| 
| RETGETPAGESIZETYPE getpagesize (void);
| #endif
| char foo;
| int main () {
|   unsigned long pagesize = getpagesize();
| #define page_align(address)  (char*)((unsigned long)(address) & -pagesize)
| 
|   char* area = (char*) malloc(6*pagesize);
|   char* fault_address = area + pagesize*7/2;
| 
|   nocrash_init();
|   if (mprotect(page_align(fault_address),pagesize,PROT_READ) < 0) exit(0);
|   *fault_address = 'z'; /* this should cause an exception or signal */
|   exit(0); }
configure:5073: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:5073: $? = 0
configure:5073: ./conftest
configure:5073: $? = 0
configure:5090: result: yes
configure:5101: checking sys/shm.h usability
configure:5101: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:5101: $? = 0
configure:5101: result: yes
configure:5101: checking sys/shm.h presence
configure:5101: /usr/bin/cc -E  conftest.c
configure:5101: $? = 0
configure:5101: result: yes
configure:5101: checking for sys/shm.h
configure:5101: result: yes
configure:5114: checking sys/ipc.h usability
configure:5114: /usr/bin/cc -c -O3 -w -pipe  conftest.c >&5
configure:5114: $? = 0
configure:5114: result: yes
configure:5114: checking sys/ipc.h presence
configure:5114: /usr/bin/cc -E  conftest.c
configure:5114: $? = 0
configure:5114: result: yes
configure:5114: checking for sys/ipc.h
configure:5114: result: yes
configure:5128: checking for working shared memory
configure:5157: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:5157: $? = 0
configure:5157: ./conftest
configure:5157: $? = 1
configure: program exited with status 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| #define HAVE_MMAP /**/
| #define HAVE_MPROTECT 1
| #define HAVE_WORKING_MPROTECT /**/
| #define HAVE_SYS_SHM_H 1
| #define HAVE_SYS_IPC_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
| #include <sys/ipc.h>
| #include <sys/shm.h>
| /* try attaching a single segment to multiple addresses */
| #define segsize 0x10000
| #define attaches 128
| #define base_addr 0x01000000
| int main ()
| { int shmid, i; char* addr; char* result;
|   if ((shmid = shmget(IPC_PRIVATE,segsize,0400)) < 0) exit(1);
|   for (i=0, addr = (char*)0x01000000; i<attaches; i++, addr += segsize)
|     if ((result = (char*)shmat(shmid,addr,SHM_RDONLY)) == (char*)(-1)) break;
|   for (i=0, addr = (char*)0x01000000; i<attaches; i++, addr += segsize)
|     shmdt(addr);
|   shmctl(shmid,IPC_RMID,0);
|   exit(result == (char*)(-1));
| }
configure:5168: result: no
configure:5192: checking whether code in malloc()ed memory is executable
configure:5307: /usr/bin/cc -o conftest -O3 -w -pipe   conftest.c  >&5
configure:5307: $? = 0
configure:5307: ./conftest
configure:5307: $? = 1
configure: program exited with status 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libffcall/trampoline"
| #define PACKAGE_TARNAME "libffcall-trampoline"
| #define PACKAGE_VERSION "0x010B"
| #define PACKAGE_STRING "libffcall/trampoline 0x010B"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define ASM_UNDERSCORE /**/
| #ifndef __x86_64__
| #define __x86_64__ 1
| #endif
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE /**/
| #define RETGETPAGESIZETYPE int
| #define HAVE_MMAP /**/
| #define HAVE_MPROTECT 1
| #define HAVE_WORKING_MPROTECT /**/
| #define HAVE_SYS_SHM_H 1
| #define HAVE_SYS_IPC_H 1
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #if defined __MACH__ && defined __APPLE__
| /* Avoid a crash on MacOS X.  */
| #include <mach/mach.h>
| #include <mach/mach_error.h>
| #include <mach/thread_status.h>
| #include <mach/exception.h>
| #include <mach/task.h>
| #include <pthread.h>
| /* The exception port on which our thread listens.  */
| static mach_port_t our_exception_port;
| /* The main function of the thread listening for exceptions of type
|    EXC_BAD_ACCESS.  */
| static void *
| mach_exception_thread (void *arg)
| {
|   /* Buffer for a message to be received.  */
|   struct {
|     mach_msg_header_t head;
|     mach_msg_body_t msgh_body;
|     char data[1024];
|   } msg;
|   mach_msg_return_t retval;
|   /* Wait for a message on the exception port.  */
|   retval = mach_msg (&msg.head, MACH_RCV_MSG | MACH_RCV_LARGE, 0, sizeof (msg),
|                      our_exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
|   if (retval != MACH_MSG_SUCCESS)
|     abort ();
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
|   mach_port_t self = mach_task_self ();
|   /* Allocate a port on which the thread shall listen for exceptions.  */
|   if (mach_port_allocate (self, MACH_PORT_RIGHT_RECEIVE, &our_exception_port)
|       == KERN_SUCCESS) {
|     /* See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_port_insert_right.html.  */
|     if (mach_port_insert_right (self, our_exception_port, our_exception_port,
|                                 MACH_MSG_TYPE_MAKE_SEND)
|         == KERN_SUCCESS) {
|       /* The exceptions we want to catch.  Only EXC_BAD_ACCESS is interesting
|          for us.  */
|       exception_mask_t mask = EXC_MASK_BAD_ACCESS;
|       /* Create the thread listening on the exception port.  */
|       pthread_attr_t attr;
|       pthread_t thread;
|       if (pthread_attr_init (&attr) == 0
|           && pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) == 0
|           && pthread_create (&thread, &attr, mach_exception_thread, NULL) == 0) {
|         pthread_attr_destroy (&attr);
|         /* Replace the exception port info for these exceptions with our own.
|            Note that we replace the exception port for the entire task, not only
|            for a particular thread.  This has the effect that when our exception
|            port gets the message, the thread specific exception port has already
|            been asked, and we don't need to bother about it.
|            See http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_set_exception_ports.html.  */
|         task_set_exception_ports (self, mask, our_exception_port,
|                                   EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
|       }
|     }
|   }
| }
| #else
| /* Avoid a crash on POSIX systems.  */
| #include <signal.h>
| /* A POSIX signal handler.  */
| static void
| exception_handler (int sig)
| {
|   exit (1);
| }
| static void
| nocrash_init (void)
| {
| #ifdef SIGSEGV
|   signal (SIGSEGV, exception_handler);
| #endif
| #ifdef SIGBUS
|   signal (SIGBUS, exception_handler);
| #endif
| }
| #endif
| 
| #include <sys/types.h>
| /* declare malloc() */
| #include <stdlib.h>
| int fun () { return 31415926; }
| int main ()
| { nocrash_init();
|  {long size = (char*)&main - (char*)&fun;
|   char* funcopy = (char*) malloc(size);
|   int i;
|   for (i = 0; i < size; i++) { funcopy[i] = ((char*)&fun)[i]; }
|   return !((*(int(*)())funcopy)() == 31415926);
| }}
configure:5322: result: no
configure:5482: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by libffcall/trampoline config.status 0x010B, which was
generated by GNU Autoconf 2.65.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on vinyl

config.status:837: creating Makefile
config.status:837: creating config.h
config.status:1003: config.h is unchanged
config.status:837: creating trampoline.h

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-apple-darwin10.4.0
ac_cv_c_compiler_gnu=yes
ac_cv_env_CC_set=set
ac_cv_env_CC_value=/usr/bin/cc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value='-O3 -w -pipe'
ac_cv_env_CPPFLAGS_set=
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=
ac_cv_env_LDFLAGS_value=
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-apple-darwin10.4.0
ac_cv_env_host_alias_set=
ac_cv_env_host_alias_value=
ac_cv_env_target_alias_set=
ac_cv_env_target_alias_value=
ac_cv_func_mmap=yes
ac_cv_func_mprotect=yes
ac_cv_header_inttypes_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_stdc=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_ipc_h=yes
ac_cv_header_sys_mman_h=yes
ac_cv_header_sys_shm_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_unistd_h=yes
ac_cv_host=x86_64-apple-darwin10.4.0
ac_cv_objext=o
ac_cv_path_EGREP='/usr/bin/grep -E'
ac_cv_path_GREP=/usr/bin/grep
ac_cv_path_install='/usr/bin/install -c'
ac_cv_prog_CPP='/usr/bin/cc -E'
ac_cv_prog_ac_ct_CC=/usr/bin/cc
ac_cv_prog_ac_ct_RANLIB=ranlib
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_gcc_traditional=no
ac_cv_prog_make_make_set=yes
cl_cv_func_getpagesize=yes
cl_cv_func_mmap_works=no
cl_cv_func_mprotect_works=yes
cl_cv_func_vm=no
cl_cv_prog_LN=ln
cl_cv_prog_LN_S_works=yes
cl_cv_prog_as_underscore=yes
cl_cv_prog_cc_gcc=yes
cl_cv_proto_getpagesize='extern int getpagesize (void);'
cl_cv_proto_getpagesize_ret=int
cl_cv_sys_shm_works=no
ffcall_cv_codeexec=no
gl_cv_host_cpu_c_abi=x86_64

## ----------------- ##
## Output variables. ##
## ----------------- ##

AS_UNDERSCORE='true'
CC='/usr/bin/cc'
CC_GCC='true'
CFLAGS='-O3 -w -pipe'
CPP='/usr/bin/cc -E'
CPPFLAGS=''
CPU_OBJECTS=''
DEFS='-DHAVE_CONFIG_H'
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/bin/grep -E'
EXEEXT=''
GCC_X_NONE='-x none'
GREP='/usr/bin/grep'
HOST_CPU_C_ABI='x86_64'
INSTALL_DATA='${INSTALL} -m 644'
INSTALL_PROGRAM='${INSTALL}'
INSTALL_SCRIPT='${INSTALL}'
LDFLAGS=''
LIBOBJS=''
LIBS=''
LN='ln'
LN_S='ln -s'
LTLIBOBJS=''
OBJEXT='o'
PACKAGE_BUGREPORT=''
PACKAGE_NAME='libffcall/trampoline'
PACKAGE_STRING='libffcall/trampoline 0x010B'
PACKAGE_TARNAME='libffcall-trampoline'
PACKAGE_URL=''
PACKAGE_VERSION='0x010B'
PATH_SEPARATOR=':'
RANLIB='ranlib'
SET_MAKE=''
SHELL='/bin/sh'
ac_ct_CC='/usr/bin/cc'
bindir='${exec_prefix}/bin'
build='x86_64-apple-darwin10.4.0'
build_alias='x86_64-apple-darwin10.4.0'
build_cpu='x86_64'
build_os='darwin10.4.0'
build_vendor='apple'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
exec_prefix='${prefix}'
host='x86_64-apple-darwin10.4.0'
host_alias=''
host_cpu='x86_64'
host_os='darwin10.4.0'
host_vendor='apple'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='${datarootdir}/info'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr/local'
program_transform_name='s,x,x,'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target_alias=''

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "libffcall/trampoline"
#define PACKAGE_TARNAME "libffcall-trampoline"
#define PACKAGE_VERSION "0x010B"
#define PACKAGE_STRING "libffcall/trampoline 0x010B"
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define ASM_UNDERSCORE /**/
#ifndef __x86_64__
#define __x86_64__ 1
#endif
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define HAVE_UNISTD_H 1
#define HAVE_GETPAGESIZE /**/
#define RETGETPAGESIZETYPE int
#define HAVE_MMAP /**/
#define HAVE_MPROTECT 1
#define HAVE_WORKING_MPROTECT /**/
#define HAVE_SYS_SHM_H 1
#define HAVE_SYS_IPC_H 1

configure: exit 0
